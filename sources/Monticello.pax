| package |
package := Package name: 'Monticello'.
package paxVersion: 1;
	basicComment: ''.

package basicPackageVersion: '0.102'.

package basicScriptAt: #postinstall put: '''Loaded: Monticello'' yourself.'.

package classNames
	add: #MCAddition;
	add: #MCClassDefinition;
	add: #MCDefinition;
	add: #MCDictionaryRepository;
	add: #MCDirectoryRepository;
	add: #MCFileBasedRepository;
	add: #MCFileTreeRepository;
	add: #MCGitHubRepository;
	add: #MCHttpRepository;
	add: #MCHttpRepositoryInfo;
	add: #MCHttpRepositoryInfoDialog;
	add: #MCMethodDefinition;
	add: #MCModification;
	add: #MCModificationTestCase;
	add: #MCOrganizationDefinition;
	add: #MCPackage;
	add: #MCPackageVersion;
	add: #MCPatch;
	add: #MCPatchBrowser;
	add: #MCPatchOperation;
	add: #MCRemoval;
	add: #MCRepository;
	add: #MCRepositoryBrowser;
	add: #MCServerDirectoryRepository;
	add: #MCVersionDialog;
	add: #MCVersionInfo;
	add: #MCVersionName;
	add: #MCWorkingCopy;
	yourself.

package methodNames
	add: #JadeServer -> #_describeMCAddition:on:;
	add: #JadeServer -> #_describeMCClassDefinition:on:;
	add: #JadeServer -> #_describeMCDefinition:on:;
	add: #JadeServer -> #_describeMCMethodDefinition:on:;
	add: #JadeServer -> #_describeMCModification:on:;
	add: #JadeServer -> #_describeMCOrganizationDefinition:on:;
	add: #JadeServer -> #_describeMCRemoval:on:;
	add: #JadeServer -> #_mcDescriptionOfPatch:baseName:alternateName:;
	add: #JadeServer -> #_mcTopazFrom:on:;
	add: #JadeServer -> #authorInitials:;
	add: #JadeServer -> #gsPackagePolicy;
	add: #JadeServer -> #gsPackagePolicyClass;
	add: #JadeServer -> #mcAddHttpRepository:;
	add: #JadeServer -> #mcAddPackage:;
	add: #JadeServer -> #mcAddRepository:toPackage:;
	add: #JadeServer -> #mcAllFileNamesIn:;
	add: #JadeServer -> #mcAllVersionInfoNamesIn:;
	add: #JadeServer -> #mcAllVersionNamesInDict:;
	add: #JadeServer -> #mcClassesInCategory:package:;
	add: #JadeServer -> #mcCreationTemplateFor:;
	add: #JadeServer -> #mcHttpRepository;
	add: #JadeServer -> #mcHttpRepository:user:password:;
	add: #JadeServer -> #mcHttpRepositoryClass;
	add: #JadeServer -> #mcInitials:;
	add: #JadeServer -> #mcInitialsA:;
	add: #JadeServer -> #mcLoadedVersionNames;
	add: #JadeServer -> #mcNewDirectoryRepository:;
	add: #JadeServer -> #mcNewFileTreeRepository:;
	add: #JadeServer -> #mcNewGitHubRepository:;
	add: #JadeServer -> #mcNewServerDirectoryRepository:;
	add: #JadeServer -> #mcPackageClass;
	add: #JadeServer -> #mcPatchFrom:to:inDictionaryRepository:;
	add: #JadeServer -> #mcPatchFrom:to:inFileBasedRepository:;
	add: #JadeServer -> #mcputDefinition:on:;
	add: #JadeServer -> #mcRemovePackage:;
	add: #JadeServer -> #mcRemoveRepository:;
	add: #JadeServer -> #mcRemoveRepository:toPackage:;
	add: #JadeServer -> #mcRepositoryFrom:;
	add: #JadeServer -> #mcRepositoryGroup;
	add: #JadeServer -> #mcRepositoryList;
	add: #JadeServer -> #mcStore:name:message:repository:;
	add: #JadeServer -> #mcTopazFrom:inDictionaryRepository:;
	add: #JadeServer -> #mcTopazFrom:inFileRepository:;
	add: #JadeServer -> #mcUniqueVersionNameFor:;
	add: #JadeServer -> #mcUserAndPasswordInHTTP:;
	add: #JadeServer -> #mcVersionInfoFrom:;
	add: #JadeServer -> #mcVersionInfoFromDictionaryPackageNamed:in:;
	add: #JadeServer -> #mcVersionInfoFromFileNamed:in:;
	add: #JadeServer -> #mcVersionLoad:fromDictionary:autoMigrate:;
	add: #JadeServer -> #mcVersionLoad:fromFile:autoMigrate:;
	add: #JadeServer -> #mcVersionMerge:from:autoMigrate:;
	add: #JadeServer -> #mcVersionNameAndMessageFrom:;
	add: #JadeServer -> #mcwcbWorkingCopies;
	add: #JadeServer -> #mcWorkingCopyClass;
	add: #JadeServer -> #mcWorkingCopyNamed:;
	add: #JadeServer -> #saveWorkingCopy:to:;
	add: #JadeServer32bit -> #mcInitialsA:;
	add: #JadeServer64bit -> #mcInitialsA:;
	add: #JadeServer64bit32 -> #gsPackagePolicy;
	add: #JadeTextDocument -> #jadeBrowseMonticello;
	add: #JadeToolsToolBarPresenter -> #browseMonticello;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: (IdentitySet new
	add: '..\Core\Object Arts\Dolphin\IDE\Base\Development System';
	add: '..\Core\Object Arts\Dolphin\Base\Dolphin';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Boolean\Dolphin Boolean Presenter';
	add: '..\Core\Object Arts\Dolphin\MVP\Views\Cards\Dolphin Card Containers';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Prompters\Dolphin Choice Prompter';
	add: '..\Core\Object Arts\Dolphin\MVP\Views\Common Controls\Dolphin Common Controls';
	add: '..\Core\Object Arts\Dolphin\MVP\Dialogs\Common\Dolphin Common Dialogs';
	add: '..\Core\Object Arts\Dolphin\MVP\Models\List\Dolphin List Models';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\List\Dolphin List Presenter';
	add: '..\Core\Object Arts\Dolphin\MVP\Base\Dolphin MVP Base';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Prompters\Dolphin Prompter';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Text\Dolphin Rich Text Presenter';
	add: '..\Core\Object Arts\Dolphin\MVP\Views\Scintilla\Dolphin Scintilla View';
	add: '..\Core\Object Arts\Dolphin\MVP\Presenters\Text\Dolphin Text Presenter';
	add: '..\Core\Object Arts\Dolphin\MVP\Type Converters\Dolphin Type Converters';
	add: '..\Core\Object Arts\Dolphin\MVP\Models\Value\Dolphin Value Models';
	add: 'GemStone Objects';
	add: 'GemStone Session';
	add: 'Jade Class Browser';
	add: 'Jade UI Base';
	add: '..\Core\Contributions\Camp Smalltalk\SUnit\SUnit';
	add: '..\Core\Object Arts\Dolphin\ActiveX\Shell\Windows Shell';
	yourself).

package!

"Class Definitions"!

Object subclass: #MCDefinition
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #MCHttpRepositoryInfo
	instanceVariableNames: 'location user password'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Object subclass: #MCVersionName
	instanceVariableNames: 'name isLoaded isModified'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCDefinition subclass: #MCClassDefinition
	instanceVariableNames: 'className definition'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCDefinition subclass: #MCMethodDefinition
	instanceVariableNames: 'classIsMeta source category selector className timeStamp'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCDefinition subclass: #MCOrganizationDefinition
	instanceVariableNames: 'categories'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Dialog subclass: #MCHttpRepositoryInfoDialog
	instanceVariableNames: 'locationPresenter userPresenter passwordPresenter'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Dialog subclass: #MCVersionDialog
	instanceVariableNames: 'namePresenter messagePresenter repositoryListPresenter httpUserPresenter httpPasswordPresenter'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
JadeShell subclass: #MCPatchBrowser
	instanceVariableNames: 'patch includeIdenticalPresenter operationListPresenter leftTextPresenter leftMemoPresenter rightTextPresenter rightMemoPresenter'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
JadeShell subclass: #MCRepositoryBrowser
	instanceVariableNames: 'repositoryListPresenter packageListPresenter versionListPresenter repositoryCreationTemplatePresenter versionNamePresenter versionDatePresenter versionTimePresenter versionAuthorPresenter versionIDPresenter versionAncestorsPresenter versionStepChildrenPresenter versionMessagePresenter loadedVersionNames'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
GsObject subclass: #MCPackage
	instanceVariableNames: 'repository versionNames loaded'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
GsObject subclass: #MCPackageVersion
	instanceVariableNames: 'date time author id ancestors stepChildren message'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
GsObject subclass: #MCPatch
	instanceVariableNames: 'operations'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
GsObject subclass: #MCPatchOperation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
GsObject subclass: #MCRepository
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
GsObject subclass: #MCVersionInfo
	instanceVariableNames: 'date time author id ancestors stepChildren message'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
GsObject subclass: #MCWorkingCopy
	instanceVariableNames: 'isModified ancestors repositories'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCPatchOperation subclass: #MCAddition
	instanceVariableNames: 'definition'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCPatchOperation subclass: #MCModification
	instanceVariableNames: 'obsoletion obsoletionMemo obsoletionMemoMarkers obsoletionLines modification modificationMemo modificationMemoMarkers modificationLines'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCPatchOperation subclass: #MCRemoval
	instanceVariableNames: 'definition'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCRepository subclass: #MCDictionaryRepository
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCRepository subclass: #MCFileBasedRepository
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCFileBasedRepository subclass: #MCDirectoryRepository
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCFileBasedRepository subclass: #MCHttpRepository
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCDirectoryRepository subclass: #MCServerDirectoryRepository
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCServerDirectoryRepository subclass: #MCFileTreeRepository
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MCFileTreeRepository subclass: #MCGitHubRepository
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
TestCase subclass: #MCModificationTestCase
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!


"Loose Methods"!

!JadeServer methodsFor!

_describeMCAddition: anMCAddition on: aStream

	aStream 
		nextPut: $A; tab;
		nextPutAll: (self oopOf: anMCAddition) printString; tab;
		yourself.
	self 
		_describeMCDefinition: anMCAddition definition 
		on: aStream.
!

_describeMCClassDefinition: anMCClassDefinition on: aStream

	| string |
	string := anMCClassDefinition definitionString collect: [:char |
		char = Character lf
			ifTrue: [Character cr]
			ifFalse: [char].
	].
	aStream
		nextPut: $C; tab;
		nextPutAll: string; lf;
		yourself.
!

_describeMCDefinition: anMCDefinition on: aStream

	anMCDefinition isMethodDefinition ifTrue: [
		self 
			_describeMCMethodDefinition: anMCDefinition 
			on: aStream.
		^self.
	].
	anMCDefinition isOrganizationDefinition ifTrue: [
		self 
			_describeMCOrganizationDefinition: anMCDefinition 
			on: aStream.
		^self.
	].
	anMCDefinition isClassDefinition ifTrue: [
		self 
			_describeMCClassDefinition: anMCDefinition 
			on: aStream.
		^self.
	].
	self halt.
!

_describeMCMethodDefinition: anMCMethodDefinition on: aStream

	aStream
		nextPut: $M; tab;
		nextPutAll: anMCMethodDefinition timeStamp; tab;
		nextPutAll: anMCMethodDefinition className; tab;
		nextPutAll: anMCMethodDefinition classIsMeta printString; tab;
		nextPutAll: anMCMethodDefinition category; tab;
		nextPutAll: anMCMethodDefinition selector; tab;
		nextPutAll: anMCMethodDefinition source size printString; tab;
		nextPutAll: anMCMethodDefinition source; lf.
!

_describeMCModification: anMCModification on: aStream

	aStream nextPut: $M; tab;
		nextPutAll: (self oopOf: anMCModification) printString; tab;
		yourself.
	self 
		_describeMCDefinition: anMCModification obsoletion 
		on: aStream.
	self 
		_describeMCDefinition: anMCModification modification 
		on: aStream.
!

_describeMCOrganizationDefinition: anMCOrganizationDefinition on: aStream

	aStream
		nextPut: $O; tab;
		yourself.
	anMCOrganizationDefinition categories do: [:each | 
		aStream nextPutAll: each; tab.
	].
	aStream lf.
!

_describeMCRemoval: anMCRemoval on: aStream

	aStream nextPut: $R; tab;
		nextPutAll: (self oopOf: anMCRemoval) printString; tab;
		yourself.
	self 
		_describeMCDefinition: anMCRemoval definition 
		on: aStream.
!

_mcDescriptionOfPatch: aPatch baseName: aString1 alternateName: aString2

	| stream |
	stream := WriteStream on: String new.
	(self oopOf: aPatch) printOn: stream.
	stream 
		tab; nextPutAll: (aString1 isNil ifTrue: ['loaded'] ifFalse: [aString1]);
		nextPutAll: ' vs. ';
		nextPutAll: (aString2 isNil ifTrue: ['loaded'] ifFalse: [aString2]);
		lf.
	aPatch operations do: [:each | 
		each isAddition 		ifTrue: [self _describeMCAddition: 		each on: stream].
		each isModification 	ifTrue: [self _describeMCModification: 	each on: stream].
		each isRemoval 		ifTrue: [self _describeMCRemoval: 		each on: stream].
	].
	^stream contents.

!

_mcTopazFrom: aSnapshot on: aStream

	| classes dict parents methods queue |
	classes := aSnapshot definitions select: [:each | each isClassDefinition].
	dict := Dictionary new.
	classes do: [:each | 
		| parent myself |
		parent := dict 
			at: each superclassName 
			ifAbsentPut: [nil -> Set new].
		myself := dict
			at: each className
			ifAbsentPut: [nil -> Set new].
		myself key: each.
		parent value add: myself.
	].
	dict := dict reject: [:each | each key isNil].
	parents := dict keys.
	dict copy do: [:each | 
		(parents includes: each key superclassName) ifTrue: [
			dict removeKey: each key className.
		].
	].
	queue := (dict asSortedCollection: [:a :b | a key <= b key]) asOrderedCollection.
	[
		queue notEmpty.
	] whileTrue: [
		| assoc children def |
		assoc := queue removeFirst.
		children := (assoc value asSortedCollection: [:a :b | a key <= b key]) asOrderedCollection.
		queue := children , queue.
		def := assoc key.
		aStream 
			nextPutAll: '!! - ' , def className; lf;
			nextPutAll: '!! - ' , def commentStamp; lf;
			nextPutAll: 'run'; lf;
			nextPutAll: '(' , def superclassName; lf;
			tab; nextPutAll: 'subclass: ' , def className printString; lf;
			tab; nextPutAll: 'instVarNames: #(' , def instanceVariablesString , ')'; lf;
			tab; nextPutAll: 'classVars: #(' , def classVariablesString , ')'; lf;
			tab; nextPutAll: 'classInstVars: #(' , def classInstanceVariablesString , ')'; lf;
			tab; nextPutAll: 'poolDictionaries: #(' , def sharedPoolsString , ')'; lf;
			tab; nextPutAll: 'inDictionary: UserGlobals'; lf;
			tab; nextPutAll: 'instancesInvariant: false'; lf;
			tab; nextPutAll: 'isModifiable: false)'; lf;
			tab; nextPutAll: 'category: ' , def category printString , '.'; lf;
			nextPutAll: 'true.'; lf;
			nextPut: $%; lf;
			yourself.
	].
	methods := aSnapshot definitions select: [:each | each isMethodDefinition].
	methods := methods asSortedCollection.
	classes asSortedCollection do: [:eachClass | 
		| localMethods |
		localMethods := methods select: [:eachMethod | eachClass className = eachMethod className].
		methods removeAll: localMethods.
		aStream
			lf; nextPutAll: '!! - *** - ' , eachClass className; lf;
			nextPutAll: 'removeAllClassMethods ' , eachClass className; lf;
			nextPutAll: 'removeAllMethods ' , eachClass className; lf;
			yourself.
		localMethods do: [:eachMethod | 
			| source |
			source := eachMethod source copyReplaceAll: Character cr asString with: Character lf asString.
			aStream
				nextPutAll: 'category: ''' , eachMethod category , ''''; lf;
				nextPutAll: '!! - ' , eachMethod timeStamp; lf;
				nextPutAll: (eachMethod classIsMeta ifTrue: ['classMethod: '] ifFalse: ['method: ']) , eachMethod className; lf;
				nextPutAll: source; lf;
				nextPut: $%; lf;
				yourself.
		].
	].
	aStream lf; nextPutAll: '!! - *** - loose methods (where class is expected to be already defined)'; lf; lf.
	methods isEmpty ifTrue: [aStream nextPutAll: '!! - (none)'; lf; lf].

	methods do: [:eachMethod | 
		| source |
		source := eachMethod source copyReplaceAll: Character cr asString with: Character lf asString.
		aStream
			nextPutAll: 'category: ''' , eachMethod category , ''''; lf;
			nextPutAll: '!! - ' , eachMethod timeStamp; lf;
			nextPutAll: (eachMethod classIsMeta ifTrue: ['classMethod: '] ifFalse: ['method: ']) , eachMethod className; lf;
			nextPutAll: source; lf;
			nextPut: $%; lf;
			yourself.
	].

	aStream lf; nextPutAll: '!! - *** - class initialization'; lf.
	methods isEmpty ifTrue: [aStream nextPutAll: '!! - (none)'; lf; lf].
	classes do: [:each | 
		aStream nextPutAll: 'send ' , each className , ' initialize'; lf.
	].

!

authorInitials: aString

	| packagePolicy |
	(packagePolicy := self gsPackagePolicy) isNil ifTrue: [^self].
	packagePolicy authorInitials: aString.
!

gsPackagePolicy

	| class |
	class := self gsPackagePolicyClass.
	class isNil ifTrue: [^nil].
	^class current.
!

gsPackagePolicyClass

	^self objectInBaseNamed: #'GsPackagePolicy'.
!

mcAddHttpRepository: aString

	| list repositoryClass repository group |
	list := aString subStrings: (Character codePoint: 255).
	(repositoryClass := self mcHttpRepositoryClass) isNil ifTrue: [self error: 'MCHttpRepository not found!!'].
	repository := repositoryClass
		location: (list at: 1)
		user: (list at: 2)
		password: (list at: 3).
	(group := self mcRepositoryGroup) isNil ifTrue: [self error: 'MCRepositoryGroup not found!!'].
	group addRepository: repository.
	^repository!

mcAddPackage: aString

	self mcWorkingCopyClass forPackage: (self mcPackageClass named: aString).
!

mcAddRepository: aRepository toPackage: aMCWorkingCopy

	aMCWorkingCopy repositoryGroup addRepository: aRepository.
!

mcAllFileNamesIn: anMCRepository

	| stream |
	stream := WriteStream on: String new.
	anMCRepository allFileNames do: [:each | 
		stream nextPutAll: each; lf.
	].
	^stream contents.
!

mcAllVersionInfoNamesIn: anMCRepository

	| stream |
	stream := WriteStream on: String new.
	anMCRepository allVersionInfos do: [:each | 
		stream nextPutAll: each name; lf.
	].
	^stream contents.
!

mcAllVersionNamesInDict: anMCRepository

	| stream list |
	stream := WriteStream on: String new.
	list := anMCRepository dictionary values.
	list := list asSortedCollection: [:a :b | 
		a package name < b package name or: [
		a package name = b package name and: [
		a info date > b info date or: [
		a info date = b info date and: [
		a info time > b info time
	]]]]].
	stream := WriteStream on: String new.
	list do: [:each | 
		stream nextPutAll: each info name; lf.
	].
	^stream contents.
!

mcClassesInCategory: aString package: aMCWorkingCopy

	| visibleClasses allClasses stream queue |
	visibleClasses := aString isNil ifTrue: [
		aMCWorkingCopy packageInfo classes.
	] ifFalse: [
		aMCWorkingCopy packageInfo classes select: [:each | 
			each _classCategory notNil and: [
			each _classCategory = aString or: [
			aString notNil and: [each _classCategory matchPattern: (Array with: aString with: $*)]]]]
	].
	allClasses := visibleClasses asIdentitySet.
	queue := visibleClasses asOrderedCollection.
	[
		queue notEmpty.
	] whileTrue: [
		| parent |
		parent := queue removeFirst superclass.
		(parent notNil and: [(allClasses includes: parent) not]) ifTrue: [
			queue add: parent.
			allClasses add: parent.
		].
	].
	stream := WriteStream on: String new.
	allClasses do: [:each |
		self
			_addClass: each 
			toStream: stream 
			isVisible: (visibleClasses includes: each)
			fromDictionary: nil.
	].
	^stream contents.
!

mcCreationTemplateFor: anMCRepository

	^anMCRepository asCreationTemplate.
!

mcHttpRepository

	^self objectInBaseNamed: #'MCHttpRepository'.
!

mcHttpRepository: aRepository user: userString password: passwordString

	aRepository
		user: userString;
		password: passwordString;
		yourself.
!

mcHttpRepositoryClass

	^self objectInBaseNamed: #'MCHttpRepository'.
!

mcInitials: aString
	"Do initial setup and return useful information"

	| mcPlatformSupport packagePolicyEnabledFlag string x |
	string := 'Jade-' , GsSession currentSession serialNumber printString , '-' , System myUserProfile userId.
	[
		self mcInitialsA: string.
	] whileFalse: [	"Keep shortening it till it fits!!"
		string := string copyFrom: 1 to: string size - 1.
	].
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	mcPlatformSupport notNil ifTrue: [mcPlatformSupport setAuthorInitials: aString].
	packagePolicyEnabledFlag := (x := self objectInBaseNamed: #'GsPackagePolicy') isNil ifTrue: ['0'] ifFalse: [x current enabled ifTrue: ['1'] ifFalse: ['0']].
	^System session printString , Character space asString , 
		(GsSession serialOfSession: System session) printString , Character space asString , 
		packagePolicyEnabledFlag
!

mcInitialsA: aString
	"Subclasses provide error handling, typically means string is too long"

	System _cacheName: aString.
!

mcLoadedVersionNames

	| mcWorkingCopyClass stream |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^nil].
	stream := WriteStream on: String new.
	mcWorkingCopyClass allManagers do: [:each | 
		| packageOrVersion |
		packageOrVersion := each ancestors
			detect: [:ignored | true]
			ifNone: [each package].
		packageOrVersion := packageOrVersion notNil
			ifTrue: [packageOrVersion name]
			ifFalse: [''].
		stream
			nextPutAll: packageOrVersion; tab;
			nextPut: (each modified ifTrue: [$Y] ifFalse: [$N]); tab;
			nextPutAll: each package name;
			lf.
	].
	^stream contents.
!

mcNewDirectoryRepository: aString

	| mcRepositoryClass fileDirectoryClass repository |
	(mcRepositoryClass := self objectInBaseNamed: #'MCDirectoryRepository') isNil ifTrue: [self error: 'Monticello not available!!'].
	(fileDirectoryClass := self objectInBaseNamed: #'FileDirectory') isNil ifTrue: [self error: 'Monticello not available!!'].
	repository := mcRepositoryClass new directory: (fileDirectoryClass on: aString).
	self mcRepositoryGroup addRepository: repository.
	^repository!

mcNewFileTreeRepository: aString

	| mcRepositoryClass fileDirectoryClass repository |
	(mcRepositoryClass := self objectInBaseNamed: #'MCFileTreeRepository') isNil ifTrue: [self error: 'Monticello not available!!'].
	(fileDirectoryClass := self objectInBaseNamed: #'ServerFileDirectory') isNil ifTrue: [self error: 'Monticello not available!!'].
	repository := mcRepositoryClass new directory: (fileDirectoryClass on: aString).
	self mcRepositoryGroup addRepository: repository.
	^repository!

mcNewGitHubRepository: aString

	| mcRepositoryClass repository |
	(mcRepositoryClass := self objectInBaseNamed: #'MCGitHubRepository') isNil ifTrue: [self error: 'Monticello not available!!'].
	repository := mcRepositoryClass location: aString.
	self mcRepositoryGroup addRepository: repository.
	^mcRepositoryClass!

mcNewServerDirectoryRepository: aString

	| mcDirectoryRepositoryClass fileDirectoryClass repository |
	(mcDirectoryRepositoryClass := self objectInBaseNamed: #'MCServerDirectoryRepository') isNil ifTrue: [self error: 'Monticello not available!!'].
	(fileDirectoryClass := self objectInBaseNamed: #'ServerFileDirectory') isNil ifTrue: [self error: 'Monticello not available!!'].
	repository := mcDirectoryRepositoryClass new directory: (fileDirectoryClass on: aString).
	self mcRepositoryGroup addRepository: repository.
	^repository!

mcPackageClass

	^self objectInBaseNamed: #'MCPackage'.
!

mcPatchFrom: aString1 to: aString2 inDictionaryRepository: aDictionaryRepository

	| index name leftSnapshot rightSnapshot patch |
	index := aString2 findLast: [:each | each = $-].
	name := aString2 copyFrom: 1 to: index - 1.
	(name includes: $.) ifTrue: [name := (name subStrings: $.) first].
	leftSnapshot := aString1 isNil ifTrue: [
		(self mcWorkingCopyClass allManagers detect: [:each | each package name = name]) package snapshot.
	] ifFalse: [
		(aDictionaryRepository versionFromVersionNamed: aString1) snapshot.
	].
	rightSnapshot := (aDictionaryRepository versionFromVersionNamed: aString2) snapshot.
	patch := rightSnapshot patchRelativeToBase: leftSnapshot.
	^self 
		_mcDescriptionOfPatch: patch
		baseName: aString1
		alternateName: aString2.
!

mcPatchFrom: aString1 to: aString2 inFileBasedRepository: aFileRepository

	| index name leftSnapshot rightSnapshot patch |
	index := aString2 findLast: [:each | each = $-].
	name := aString2 copyFrom: 1 to: index - 1.
	(name includes: $.) ifTrue: [name := (name subStrings: $.) first].
	leftSnapshot := aString1 isNil ifTrue: [
		(self mcWorkingCopyClass allManagers detect: [:each | each package name = name]) package snapshot.
	] ifFalse: [
		(aFileRepository versionFromFileNamed: aString1) snapshot.
	].
	rightSnapshot := (aFileRepository versionFromFileNamed: aString2) snapshot.
	patch := rightSnapshot patchRelativeToBase: leftSnapshot.
	^self 
		_mcDescriptionOfPatch: patch
		baseName: aString1
		alternateName: aString2.
!

mcputDefinition: aDefinition on: aStream

	| mcOrganizationDefinitionClass mcClassDefinitionClass mcMethodDefinitionClass |
	(mcOrganizationDefinitionClass := self objectInBaseNamed: 'MCOrganizationDefinition') isNil ifTrue: [^nil].
	(mcClassDefinitionClass := self objectInBaseNamed: 'MCClassDefinitionClass') isNil ifTrue: [^nil].
	(mcMethodDefinitionClass := self objectInBaseNamed: 'MCMethodDefinition') isNil ifTrue: [^nil].

	self _addToPureExportSet: aDefinition.
		aStream nextPutAll: (self oopOf: aDefinition) printString; tab;
			nextPutAll: aDefinition class name; tab.
			
		aDefinition class == mcOrganizationDefinitionClass ifTrue: [
			aDefinition categories do: [:eachCategory | 
				aStream nextPutAll: eachCategory; space]
		] ifFalse: [	aDefinition class == mcClassDefinitionClass ifTrue: [
			aStream
				nextPutAll: aDefinition className; tab;
				nextPutAll: aDefinition superclassName; tab;
				nextPutAll: aDefinition category; tab;
				nextPutAll: aDefinition type; tab;
				yourself.
		] ifFalse: [aDefinition class == mcMethodDefinitionClass ifTrue: [
			aStream
				nextPutAll: aDefinition classIsMeta printString; tab;
				nextPutAll: aDefinition category; tab;
				nextPutAll: aDefinition selector; tab;
				nextPutAll: aDefinition className; tab;
				nextPutAll: aDefinition timeStamp printString; tab]]].
	
	^aStream.
	!

mcRemovePackage: anMCWorkingCopy

	anMCWorkingCopy unregister.
!

mcRemoveRepository: aRepository

	| repositoryClass group |
	(repositoryClass := self mcHttpRepositoryClass) isNil ifTrue: [self error: 'MCHttpRepository not found!!'].
	(group := self mcRepositoryGroup) isNil ifTrue: [self error: 'MCRepositoryGroup not found!!'].
	group removeRepository: aRepository.
!

mcRemoveRepository: aRepository toPackage: aMCWorkingCopy

	aMCWorkingCopy repositoryGroup removeRepository: aRepository.
!

mcRepositoryFrom: aRepository

	| stream |
	stream := WriteStream on: String new.
	(self oopOf: aRepository) printOn: stream.
	stream 
		tab;
		nextPutAll: aRepository description;
		tab;
		nextPutAll: aRepository class name;
		tab.
	^stream contents.
!

mcRepositoryGroup

	| groupClass |
	(groupClass := self objectInBaseNamed: 'MCRepositoryGroup') isNil ifTrue: [^nil].
	^groupClass default.
!

mcRepositoryList

	| group stream |
	(group := self mcRepositoryGroup) isNil ifTrue: [^nil].
	stream := WriteStream on: String new.
	group repositories do: [:each | 
		stream nextPutAll: (self mcRepositoryFrom: each).
		stream lf.
	].
	^stream contents.
!

mcStore: aMCWorkingCopy name: nameString message: messageString repository: aRepository 

	| version |
	version := (aMCWorkingCopy needsSaving not and: [aMCWorkingCopy currentVersionInfo name = nameString]) ifTrue: [
		(self objectInBaseNamed: #'MCVersion')
			package: aMCWorkingCopy package
			info: aMCWorkingCopy currentVersionInfo.
	] ifFalse: [
		aMCWorkingCopy
			newVersionWithName: nameString
			message: messageString.
	].
	aRepository storeVersion: version.
	(self objectInBaseNamed: #'MCCacheRepository') default storeVersion: version.
!

mcTopazFrom: aString inDictionaryRepository: aDictionaryRepository

	| snapshot stream |
	snapshot := (aDictionaryRepository versionFromVersionNamed: aString) snapshot.
	stream := (WriteStream on: String new)
		nextPutAll: '!! ' , aString , ' in ' , aDictionaryRepository printString; lf;
		yourself.
	self
		_mcTopazFrom: snapshot
		on: stream.
	^stream contents.

!

mcTopazFrom: aString inFileRepository: aFileRepository

	| snapshot stream |
	snapshot := (aFileRepository versionFromFileNamed: aString) snapshot.
	stream := (WriteStream on: String new)
		nextPutAll: '!! ' , aString , ' in ' , aFileRepository printString; lf;
		yourself.
	self
		_mcTopazFrom: snapshot
		on: stream.
	^stream contents.

!

mcUniqueVersionNameFor: anMCWorkingCopy

	^anMCWorkingCopy uniqueVersionName.
!

mcUserAndPasswordInHTTP: anMCHttpRepository

	^anMCHttpRepository user , Character tab asString , anMCHttpRepository password.
!

mcVersionInfoFrom: aVersionInfo

	| stream |
	stream := WriteStream on: String new.
	(self oopOf: aVersionInfo) printOn: stream.
	stream 
		lf; nextPutAll: aVersionInfo name; 
		lf; nextPutAll: aVersionInfo date yyyymmdd;
		lf.
	aVersionInfo time printOn: stream.
	stream 
		lf; nextPutAll: aVersionInfo author; 
		lf; nextPutAll: aVersionInfo id asString;
		lf.
	aVersionInfo ancestors do: [:each | 
		stream nextPutAll: each name; tab.
	].
	stream lf.
	aVersionInfo stepChildren do: [:each | 
		stream nextPutAll: each name; tab.
	].
	stream lf.
	stream nextPutAll: aVersionInfo message.
	^stream contents.
!

mcVersionInfoFromDictionaryPackageNamed: aString in: anMCDictionaryRepository

	| versionInfo |
	(versionInfo := anMCDictionaryRepository versionInfoFromVersionNamed: aString) isNil ifTrue: [^''].
	^self mcVersionInfoFrom: versionInfo.
!

mcVersionInfoFromFileNamed: aString in: anMCFileBasedRepository

	| versionInfo |
	(versionInfo := anMCFileBasedRepository versionInfoFromFileNamed: aString) isNil ifTrue: [^''].
	^self mcVersionInfoFrom: versionInfo.
!

mcVersionLoad: aString fromDictionary: anMCDictionaryRepository autoMigrate: aBoolean

	| version package workingCopy mcPlatformSupport autoMigrate |
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	autoMigrate := mcPlatformSupport autoMigrate.
	mcPlatformSupport autoMigrate: aBoolean.
	version := anMCDictionaryRepository versionFromVersionNamed: aString.
	version load.
	package := version package.
	workingCopy := self mcWorkingCopyClass forPackage: package.
	workingCopy repositoryGroup addRepository: anMCDictionaryRepository.
	mcPlatformSupport autoMigrate: autoMigrate.
!

mcVersionLoad: aString fromFile: anMCFileBasedRepository autoMigrate: aBoolean

	| version package workingCopy mcPlatformSupport autoMigrate |
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	autoMigrate := mcPlatformSupport autoMigrate.
	mcPlatformSupport autoMigrate: aBoolean.
	version := anMCFileBasedRepository loadVersionFromFileNamed: aString.
	version load.
	package := version package.
	workingCopy := self mcWorkingCopyClass forPackage: package.
	workingCopy repositoryGroup addRepository: anMCFileBasedRepository.
	mcPlatformSupport autoMigrate: autoMigrate.
!

mcVersionMerge: aString from: anMCFileBasedRepository autoMigrate: aBoolean

	| version mcPlatformSupport autoMigrate workingCopy |
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	autoMigrate := mcPlatformSupport autoMigrate.
	mcPlatformSupport autoMigrate: aBoolean.
	version := anMCFileBasedRepository loadVersionFromFileNamed: aString.
	workingCopy := self mcWorkingCopyClass forPackage: version package.
	[
		[
			workingCopy merge: version.
		] on: (self objectInBaseNamed: #'MCNoChangesException') do: [:ex | 
			ex return.
		].
	] on: (self objectInBaseNamed: #'MCMergeResolutionRequest') do: [:ex | 
self halt.
		ex merger conflicts do: [:each | each chooseRemote].
		ex merger load.
		workingCopy 
			merged: version;
			modified: true;
			yourself.
		"ex resume: true."
		ex return.
	].

!

mcVersionNameAndMessageFrom: aMCWorkingCopy

	(aMCWorkingCopy needsSaving or: [aMCWorkingCopy ancestors isEmpty]) ifTrue: [
		^'<new>	<new>'.
	].
	^aMCWorkingCopy currentVersionInfo name , Character tab asString , aMCWorkingCopy currentVersionInfo message.
!

mcwcbWorkingCopies

	| mcWorkingCopyClass list stream |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^nil].
	list := mcWorkingCopyClass allManagers.
	list := list asSortedCollection: [:a :b | a package name <= b package name].
	stream := WriteStream on: String new.
	list do: [:each |
		self saveWorkingCopy: each to: stream.
		stream lf].
	^stream contents!

mcWorkingCopyClass

	^self objectInBaseNamed: #'MCWorkingCopy'.
!

mcWorkingCopyNamed: aString

	| mcWorkingCopyClass workingCopy stream |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^nil].
	workingCopy := mcWorkingCopyClass allManagers 
		detect: [:each | each package name = aString]
		ifNone: [^nil].
	stream := WriteStream on: String new.
	self 
		saveWorkingCopy: workingCopy 
		to: stream.
	^stream contents.
!

saveWorkingCopy: wc to: stream

	self _addToPureExportSet: wc.
	stream
		nextPutAll: (self oopOf: wc) printString; tab;
		nextPutAll: wc package name; tab;
		nextPutAll: wc modified printString; tab;
		nextPutAll: wc ancestors size printString; tab;
		yourself.
	wc ancestors do: [:ancestor |
		self _addToPureExportSet: ancestor.
		(self oopOf: ancestor) printOn: stream.
		stream tab.
	].
	stream nextPutAll: wc repositoryGroup repositories size printString; tab.
	wc repositoryGroup repositories do: [:repository |
		self _addToPureExportSet: repository.
		(self oopOf: repository) printOn: stream.
		stream tab.
	].
! !
!JadeServer categoriesFor: #_describeMCAddition:on:!Monticello!private! !
!JadeServer categoriesFor: #_describeMCClassDefinition:on:!Monticello!public! !
!JadeServer categoriesFor: #_describeMCDefinition:on:!Monticello!public! !
!JadeServer categoriesFor: #_describeMCMethodDefinition:on:!Monticello!private! !
!JadeServer categoriesFor: #_describeMCModification:on:!Monticello!private! !
!JadeServer categoriesFor: #_describeMCOrganizationDefinition:on:!Monticello!public! !
!JadeServer categoriesFor: #_describeMCRemoval:on:!Monticello!private! !
!JadeServer categoriesFor: #_mcDescriptionOfPatch:baseName:alternateName:!Monticello!private! !
!JadeServer categoriesFor: #_mcTopazFrom:on:!Monticello!private! !
!JadeServer categoriesFor: #authorInitials:!Monticello!public! !
!JadeServer categoriesFor: #gsPackagePolicy!public! !
!JadeServer categoriesFor: #gsPackagePolicyClass!public! !
!JadeServer categoriesFor: #mcAddHttpRepository:!Monticello!public! !
!JadeServer categoriesFor: #mcAddPackage:!Monticello!public! !
!JadeServer categoriesFor: #mcAddRepository:toPackage:!Monticello!public! !
!JadeServer categoriesFor: #mcAllFileNamesIn:!Monticello!public! !
!JadeServer categoriesFor: #mcAllVersionInfoNamesIn:!Monticello!public! !
!JadeServer categoriesFor: #mcAllVersionNamesInDict:!Monticello!public! !
!JadeServer categoriesFor: #mcClassesInCategory:package:!Monticello!public! !
!JadeServer categoriesFor: #mcCreationTemplateFor:!Monticello!public! !
!JadeServer categoriesFor: #mcHttpRepository!Monticello!public! !
!JadeServer categoriesFor: #mcHttpRepository:user:password:!Monticello!public! !
!JadeServer categoriesFor: #mcHttpRepositoryClass!Monticello!public! !
!JadeServer categoriesFor: #mcInitials:!Monticello!public! !
!JadeServer categoriesFor: #mcInitialsA:!Monticello!public! !
!JadeServer categoriesFor: #mcLoadedVersionNames!Monticello!public! !
!JadeServer categoriesFor: #mcNewDirectoryRepository:!Monticello!public! !
!JadeServer categoriesFor: #mcNewFileTreeRepository:!Monticello!public! !
!JadeServer categoriesFor: #mcNewGitHubRepository:!Monticello!public! !
!JadeServer categoriesFor: #mcNewServerDirectoryRepository:!Monticello!public! !
!JadeServer categoriesFor: #mcPackageClass!Monticello!public! !
!JadeServer categoriesFor: #mcPatchFrom:to:inDictionaryRepository:!Monticello!public! !
!JadeServer categoriesFor: #mcPatchFrom:to:inFileBasedRepository:!Monticello!public! !
!JadeServer categoriesFor: #mcputDefinition:on:!Monticello!public! !
!JadeServer categoriesFor: #mcRemovePackage:!Monticello!public! !
!JadeServer categoriesFor: #mcRemoveRepository:!Monticello!public! !
!JadeServer categoriesFor: #mcRemoveRepository:toPackage:!Monticello!public! !
!JadeServer categoriesFor: #mcRepositoryFrom:!Monticello!public! !
!JadeServer categoriesFor: #mcRepositoryGroup!Monticello!public! !
!JadeServer categoriesFor: #mcRepositoryList!Monticello!public! !
!JadeServer categoriesFor: #mcStore:name:message:repository:!Monticello!public! !
!JadeServer categoriesFor: #mcTopazFrom:inDictionaryRepository:!Monticello!public! !
!JadeServer categoriesFor: #mcTopazFrom:inFileRepository:!Monticello!public! !
!JadeServer categoriesFor: #mcUniqueVersionNameFor:!Monticello!public! !
!JadeServer categoriesFor: #mcUserAndPasswordInHTTP:!Monticello!public! !
!JadeServer categoriesFor: #mcVersionInfoFrom:!Monticello!public! !
!JadeServer categoriesFor: #mcVersionInfoFromDictionaryPackageNamed:in:!Monticello!public! !
!JadeServer categoriesFor: #mcVersionInfoFromFileNamed:in:!Monticello!public! !
!JadeServer categoriesFor: #mcVersionLoad:fromDictionary:autoMigrate:!Monticello!public! !
!JadeServer categoriesFor: #mcVersionLoad:fromFile:autoMigrate:!Monticello!public! !
!JadeServer categoriesFor: #mcVersionMerge:from:autoMigrate:!Monticello!public! !
!JadeServer categoriesFor: #mcVersionNameAndMessageFrom:!Monticello!public! !
!JadeServer categoriesFor: #mcwcbWorkingCopies!Monticello!public! !
!JadeServer categoriesFor: #mcWorkingCopyClass!Monticello!public! !
!JadeServer categoriesFor: #mcWorkingCopyNamed:!Monticello!public! !
!JadeServer categoriesFor: #saveWorkingCopy:to:!Monticello!public! !

!JadeServer32bit methodsFor!

mcInitialsA: aString

	(System class includesSelector: #'_cacheName:') ifFalse: [^true].
	Exception
		category: nil
		number: nil
		do: [:ex :cat :num :args | ^false].
	super mcInitialsA: aString.
	^true.
! !
!JadeServer32bit categoriesFor: #mcInitialsA:!Monticello!public! !

!JadeServer64bit methodsFor!

mcInitialsA: aString

	^[
		super mcInitialsA: aString.
		true.
	] on: Error do: [:ex | 
		ex return: false.
	].
! !
!JadeServer64bit categoriesFor: #mcInitialsA:!Monticello!public! !

!JadeServer64bit32 methodsFor!

gsPackagePolicy

	| class |
	class := self gsPackagePolicyClass.
	class isNil ifTrue: [^nil].
	class enabled ifFalse: [^nil].
	^class current
! !
!JadeServer64bit32 categoriesFor: #gsPackagePolicy!public! !

!JadeTextDocument methodsFor!

jadeBrowseMonticello

	gciSession hasServer ifTrue: [
		^MCRepositoryBrowser showOnSession: gciSession.
	].
	MessageBox
		warning: 'Server initialization failed at login.'
		caption: 'Unable to Open Browser'.
! !
!JadeTextDocument categoriesFor: #jadeBrowseMonticello!Jade!private! !

!JadeToolsToolBarPresenter methodsFor!

browseMonticello

	MCRepositoryBrowser showOnSession: gciSession.
! !
!JadeToolsToolBarPresenter categoriesFor: #browseMonticello!public! !

"End of package definition"!

